/* Generated by ./xlat/gen.sh from ./xlat/drm_capability.in; do not edit. */

#include "gcc_compat.h"
#include "static_assert.h"

#if defined(DRM_CAP_DUMB_BUFFER) || (defined(HAVE_DECL_DRM_CAP_DUMB_BUFFER) && HAVE_DECL_DRM_CAP_DUMB_BUFFER)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_DUMB_BUFFER) == (0x1), "DRM_CAP_DUMB_BUFFER != 0x1");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_DUMB_BUFFER 0x1
#endif
#if defined(DRM_CAP_VBLANK_HIGH_CRTC) || (defined(HAVE_DECL_DRM_CAP_VBLANK_HIGH_CRTC) && HAVE_DECL_DRM_CAP_VBLANK_HIGH_CRTC)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_VBLANK_HIGH_CRTC) == (0x2), "DRM_CAP_VBLANK_HIGH_CRTC != 0x2");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_VBLANK_HIGH_CRTC 0x2
#endif
#if defined(DRM_CAP_DUMB_PREFERRED_DEPTH) || (defined(HAVE_DECL_DRM_CAP_DUMB_PREFERRED_DEPTH) && HAVE_DECL_DRM_CAP_DUMB_PREFERRED_DEPTH)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_DUMB_PREFERRED_DEPTH) == (0x3), "DRM_CAP_DUMB_PREFERRED_DEPTH != 0x3");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_DUMB_PREFERRED_DEPTH 0x3
#endif
#if defined(DRM_CAP_DUMB_PREFER_SHADOW) || (defined(HAVE_DECL_DRM_CAP_DUMB_PREFER_SHADOW) && HAVE_DECL_DRM_CAP_DUMB_PREFER_SHADOW)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_DUMB_PREFER_SHADOW) == (0x4), "DRM_CAP_DUMB_PREFER_SHADOW != 0x4");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_DUMB_PREFER_SHADOW 0x4
#endif
#if defined(DRM_CAP_PRIME) || (defined(HAVE_DECL_DRM_CAP_PRIME) && HAVE_DECL_DRM_CAP_PRIME)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_PRIME) == (0x5), "DRM_CAP_PRIME != 0x5");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_PRIME 0x5
#endif
#if defined(DRM_CAP_TIMESTAMP_MONOTONIC) || (defined(HAVE_DECL_DRM_CAP_TIMESTAMP_MONOTONIC) && HAVE_DECL_DRM_CAP_TIMESTAMP_MONOTONIC)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_TIMESTAMP_MONOTONIC) == (0x6), "DRM_CAP_TIMESTAMP_MONOTONIC != 0x6");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_TIMESTAMP_MONOTONIC 0x6
#endif
#if defined(DRM_CAP_ASYNC_PAGE_FLIP) || (defined(HAVE_DECL_DRM_CAP_ASYNC_PAGE_FLIP) && HAVE_DECL_DRM_CAP_ASYNC_PAGE_FLIP)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_ASYNC_PAGE_FLIP) == (0x7), "DRM_CAP_ASYNC_PAGE_FLIP != 0x7");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_ASYNC_PAGE_FLIP 0x7
#endif
#if defined(DRM_CAP_CURSOR_WIDTH) || (defined(HAVE_DECL_DRM_CAP_CURSOR_WIDTH) && HAVE_DECL_DRM_CAP_CURSOR_WIDTH)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_CURSOR_WIDTH) == (0x8), "DRM_CAP_CURSOR_WIDTH != 0x8");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_CURSOR_WIDTH 0x8
#endif
#if defined(DRM_CAP_CURSOR_HEIGHT) || (defined(HAVE_DECL_DRM_CAP_CURSOR_HEIGHT) && HAVE_DECL_DRM_CAP_CURSOR_HEIGHT)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_CURSOR_HEIGHT) == (0x9), "DRM_CAP_CURSOR_HEIGHT != 0x9");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_CURSOR_HEIGHT 0x9
#endif
#if defined(DRM_CAP_ADDFB2_MODIFIERS) || (defined(HAVE_DECL_DRM_CAP_ADDFB2_MODIFIERS) && HAVE_DECL_DRM_CAP_ADDFB2_MODIFIERS)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_ADDFB2_MODIFIERS) == (0x10), "DRM_CAP_ADDFB2_MODIFIERS != 0x10");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_ADDFB2_MODIFIERS 0x10
#endif
#if defined(DRM_CAP_PAGE_FLIP_TARGET) || (defined(HAVE_DECL_DRM_CAP_PAGE_FLIP_TARGET) && HAVE_DECL_DRM_CAP_PAGE_FLIP_TARGET)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_PAGE_FLIP_TARGET) == (0x11), "DRM_CAP_PAGE_FLIP_TARGET != 0x11");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_PAGE_FLIP_TARGET 0x11
#endif
#if defined(DRM_CAP_CRTC_IN_VBLANK_EVENT) || (defined(HAVE_DECL_DRM_CAP_CRTC_IN_VBLANK_EVENT) && HAVE_DECL_DRM_CAP_CRTC_IN_VBLANK_EVENT)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_CRTC_IN_VBLANK_EVENT) == (0x12), "DRM_CAP_CRTC_IN_VBLANK_EVENT != 0x12");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_CRTC_IN_VBLANK_EVENT 0x12
#endif
#if defined(DRM_CAP_SYNCOBJ) || (defined(HAVE_DECL_DRM_CAP_SYNCOBJ) && HAVE_DECL_DRM_CAP_SYNCOBJ)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_SYNCOBJ) == (0x13), "DRM_CAP_SYNCOBJ != 0x13");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_SYNCOBJ 0x13
#endif
#if defined(DRM_CAP_SYNCOBJ_TIMELINE) || (defined(HAVE_DECL_DRM_CAP_SYNCOBJ_TIMELINE) && HAVE_DECL_DRM_CAP_SYNCOBJ_TIMELINE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((DRM_CAP_SYNCOBJ_TIMELINE) == (0x14), "DRM_CAP_SYNCOBJ_TIMELINE != 0x14");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define DRM_CAP_SYNCOBJ_TIMELINE 0x14
#endif

#ifndef XLAT_MACROS_ONLY

# ifdef IN_MPERS

#  error static const struct xlat drm_capability in mpers mode

# else

static const struct xlat_data drm_capability_xdata[] = {
 XLAT(DRM_CAP_DUMB_BUFFER),
 XLAT(DRM_CAP_VBLANK_HIGH_CRTC),
 XLAT(DRM_CAP_DUMB_PREFERRED_DEPTH),
 XLAT(DRM_CAP_DUMB_PREFER_SHADOW),
 XLAT(DRM_CAP_PRIME),
 XLAT(DRM_CAP_TIMESTAMP_MONOTONIC),
 XLAT(DRM_CAP_ASYNC_PAGE_FLIP),
 XLAT(DRM_CAP_CURSOR_WIDTH),
 XLAT(DRM_CAP_CURSOR_HEIGHT),
 XLAT(DRM_CAP_ADDFB2_MODIFIERS),
 XLAT(DRM_CAP_PAGE_FLIP_TARGET),
 XLAT(DRM_CAP_CRTC_IN_VBLANK_EVENT),
 XLAT(DRM_CAP_SYNCOBJ),
 XLAT(DRM_CAP_SYNCOBJ_TIMELINE),
};
static
const struct xlat drm_capability[1] = { {
 .data = drm_capability_xdata,
 .size = ARRAY_SIZE(drm_capability_xdata),
 .type = XT_NORMAL,
} };

# endif /* !IN_MPERS */

#endif /* !XLAT_MACROS_ONLY */

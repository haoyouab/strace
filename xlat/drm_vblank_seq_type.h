/* Generated by ./xlat/gen.sh from ./xlat/drm_vblank_seq_type.in; do not edit. */

#include "gcc_compat.h"
#include "static_assert.h"

#if defined(_DRM_VBLANK_ABSOLUTE) || (defined(HAVE_DECL__DRM_VBLANK_ABSOLUTE) && HAVE_DECL__DRM_VBLANK_ABSOLUTE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((_DRM_VBLANK_ABSOLUTE) == (0x0), "_DRM_VBLANK_ABSOLUTE != 0x0");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define _DRM_VBLANK_ABSOLUTE 0x0
#endif
#if defined(_DRM_VBLANK_RELATIVE) || (defined(HAVE_DECL__DRM_VBLANK_RELATIVE) && HAVE_DECL__DRM_VBLANK_RELATIVE)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((_DRM_VBLANK_RELATIVE) == (0x1), "_DRM_VBLANK_RELATIVE != 0x1");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define _DRM_VBLANK_RELATIVE 0x1
#endif
#if defined(_DRM_VBLANK_HIGH_CRTC_MASK) || (defined(HAVE_DECL__DRM_VBLANK_HIGH_CRTC_MASK) && HAVE_DECL__DRM_VBLANK_HIGH_CRTC_MASK)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((_DRM_VBLANK_HIGH_CRTC_MASK) == (0x0000003e), "_DRM_VBLANK_HIGH_CRTC_MASK != 0x0000003e");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define _DRM_VBLANK_HIGH_CRTC_MASK 0x0000003e
#endif
#if defined(_DRM_VBLANK_EVENT) || (defined(HAVE_DECL__DRM_VBLANK_EVENT) && HAVE_DECL__DRM_VBLANK_EVENT)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((_DRM_VBLANK_EVENT) == (0x4000000), "_DRM_VBLANK_EVENT != 0x4000000");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define _DRM_VBLANK_EVENT 0x4000000
#endif
#if defined(_DRM_VBLANK_FLIP) || (defined(HAVE_DECL__DRM_VBLANK_FLIP) && HAVE_DECL__DRM_VBLANK_FLIP)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((_DRM_VBLANK_FLIP) == (0x8000000), "_DRM_VBLANK_FLIP != 0x8000000");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define _DRM_VBLANK_FLIP 0x8000000
#endif
#if defined(_DRM_VBLANK_NEXTONMISS) || (defined(HAVE_DECL__DRM_VBLANK_NEXTONMISS) && HAVE_DECL__DRM_VBLANK_NEXTONMISS)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((_DRM_VBLANK_NEXTONMISS) == (0x10000000), "_DRM_VBLANK_NEXTONMISS != 0x10000000");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define _DRM_VBLANK_NEXTONMISS 0x10000000
#endif
#if defined(_DRM_VBLANK_SECONDARY) || (defined(HAVE_DECL__DRM_VBLANK_SECONDARY) && HAVE_DECL__DRM_VBLANK_SECONDARY)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((_DRM_VBLANK_SECONDARY) == (0x20000000), "_DRM_VBLANK_SECONDARY != 0x20000000");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define _DRM_VBLANK_SECONDARY 0x20000000
#endif
#if defined(_DRM_VBLANK_SIGNAL) || (defined(HAVE_DECL__DRM_VBLANK_SIGNAL) && HAVE_DECL__DRM_VBLANK_SIGNAL)
DIAG_PUSH_IGNORE_TAUTOLOGICAL_COMPARE
static_assert((_DRM_VBLANK_SIGNAL) == (0x40000000), "_DRM_VBLANK_SIGNAL != 0x40000000");
DIAG_POP_IGNORE_TAUTOLOGICAL_COMPARE
#else
# define _DRM_VBLANK_SIGNAL 0x40000000
#endif

#ifndef XLAT_MACROS_ONLY

# ifdef IN_MPERS

extern const struct xlat drm_vblank_seq_type[];

# else

static const struct xlat_data drm_vblank_seq_type_xdata[] = {
 XLAT(_DRM_VBLANK_ABSOLUTE),
 XLAT(_DRM_VBLANK_RELATIVE),
 XLAT(_DRM_VBLANK_HIGH_CRTC_MASK),
 XLAT(_DRM_VBLANK_EVENT),
 XLAT(_DRM_VBLANK_FLIP),
 XLAT(_DRM_VBLANK_NEXTONMISS),
 XLAT(_DRM_VBLANK_SECONDARY),
 XLAT(_DRM_VBLANK_SIGNAL),
};
#  if !(defined HAVE_M32_MPERS || defined HAVE_MX32_MPERS)
static
#  endif
const struct xlat drm_vblank_seq_type[1] = { {
 .data = drm_vblank_seq_type_xdata,
 .size = ARRAY_SIZE(drm_vblank_seq_type_xdata),
 .type = XT_NORMAL,
} };

# endif /* !IN_MPERS */

#endif /* !XLAT_MACROS_ONLY */
